<!DOCTYPE html>
<html lang="en">
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
<meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">


    <meta name="author" content="yaming042">



    <meta name="keywords" content="bug,"/>



    <meta name="description" content="今天闲来无事，忽然想起了前天在开发功能时遇到的一个问题，具体情况就是我渲染了一个邮箱列表，列表支持修改邮箱，但是发现每次改完邮箱后input框就会失去焦点，按理说input是不会失去焦点的，但bug就此发生了。



需要渲染的邮箱列表数据格式 ['xiaoming@163.com','lie..."/>


<meta name="Robots" content="all">


    <title>一个改变的key引发的问题 | Coding_用代码记录点滴，Happy_用快乐享受生活</title>


<link rel="icon" href="//cache.yaming.me/githubPage/favicon.ico">

<link rel="stylesheet" href="/css/style.css">


<script src="/js/jquery.min.js"></script>


<script src="/js/av.min.js"></script>


<script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0bb2321117b8ad1f07d1fca35aa1199a";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
</script>
<meta name="generator" content="Hexo 5.4.0"></head>
<body>

    <div class="main-container">
        <div class="web-header">
    <div class="logo">TYM042</div>

    <div class="web-menu">
        <div class="menu-list clearfix">
            
                <div class="menu-item">
                    <h2>
                        <a 
                            class="menu-item-link" 
                            href="/"
                            
                        >
                            首页
                        </a>
                    </h2>
                    <span>Home</span>
                </div>
            
                <div class="menu-item">
                    <h2>
                        <a 
                            class="menu-item-link" 
                            href="/categories/博文/"
                            
                        >
                            博文
                        </a>
                    </h2>
                    <span>Blog</span>
                </div>
            
                <div class="menu-item">
                    <h2>
                        <a 
                            class="menu-item-link" 
                            href="/categories/笔记/"
                            
                        >
                            笔记
                        </a>
                    </h2>
                    <span>Notes</span>
                </div>
            
        </div>
    </div>
</div>
<div class="banner">
    <img src="//cache.yaming.me/githubPage/banner.png" alt="">
</div>
        <div class="container-box">
            <div class="container-body">
                <div class="web-article">
    <div class="web-article-container">
        <div class="web-article-view">
            <div class="article-baseinfo">
                <h2>一个改变的key引发的问题</h2>
                <div class="other-info">
                    <span>发布时间：2021-04-04</span>
                    <span>作者：yaming042</span>
                    
                        <span>
                            阅读量：<i id="/20210404/20210404/" class="leancloud_visitors" data-flag-title="一个改变的key引发的问题">-</i> 次
                        </span>
                    
                    
                    <span>本文字数：12k</span>
                    <span>阅读时长 ≈ 11 分钟</span>
                </div>
            </div>
            <p>今天闲来无事，忽然想起了前天在开发功能时遇到的一个问题，具体情况就是我渲染了一个邮箱列表，列表支持修改邮箱，但是发现每次改完邮箱后input框就会失去焦点，按理说input是不会失去焦点的，但bug就此发生了。</p>
<hr>
<p><img src="//cache.yaming.me/githubPage/email.png" alt="邮件列表"></p>
<hr>
<p>需要渲染的邮箱列表数据格式 <code>['xiaoming@163.com','lier@163.com']</code>，渲染的列表支持修改，代码如下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; emails &#125; = <span class="built_in">this</span>.state;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div className=<span class="string">&quot;container&quot;</span>&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                (emails || []).map(<span class="function">(<span class="params">email, index</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> (</span><br><span class="line">                        &lt;div className=<span class="string">&quot;email-row&quot;</span> key=&#123; email &#125;&gt;</span><br><span class="line">                            &lt;input </span><br><span class="line">                                type=<span class="string">&quot;text&quot;</span> </span><br><span class="line">                                value=&#123; email &#125; </span><br><span class="line">                                onChange=&#123;<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">                                    emails[index] = (e.target.value || <span class="string">&#x27;&#x27;</span>).trim();</span><br><span class="line">                                    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">                                        emails: emails)</span><br><span class="line">                                    &#125;);</span><br><span class="line">                                &#125;&#125;    </span><br><span class="line">                            /&gt;</span><br><span class="line">                        &lt;/div&gt;</span><br><span class="line">                    );</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看完上面是否有发现问题。大体看上去没啥问题，但是在页面上实际测过后你会发现一个bug，每次敲击完键盘，input输入框会失去焦点，那么为什么会发生这种bug呢，其实你回想下react的渲染流程应该就会发现问题。<br><strong>先说原因：</strong>因为你每次change后email发生了改变，也就是说，你在渲染列表的时候，列表的 <code>key</code> 发生了改变，此时再次渲染，原来的dom已经被干掉换成新的dom了，只是看起来还是原来的那个input；<br><strong>再说处理办法：</strong>慎重定义 <code>key</code> 的值</p>
<p><strong>再说为啥：</strong>键(keys)帮助React标识哪项被修改，添加，删除<a target="_blank" rel="noopener" href="https://react.html.cn/docs/lists-and-keys.html#%E9%94%AEkeys">官方文档</a>;</p>
<p>来看下官方的解释<a target="_blank" rel="noopener" href="https://react.html.cn/docs/reconciliation.html#recursing-on-children">官方文档</a></p>
<blockquote>
<p>当你使用 React ，在任何一个单点时刻你可以认为 <code>render()</code>函数的作用是创建 React 元素树。在下一个 <code>state</code> 或<code>props</code> 更新时，<code>render()</code> 函数将会返回一个不同的 React 元素树。接下来 React 将会找出如何高效地更新 UI 来匹配最近时刻的 React 元素树。</p>
</blockquote>
<p>目前有很多通用的做法来尽可能的减少将一个dom树转换成另外一个dom树，但是这些方法的复杂度却是<code>O(n3)</code>。也就是说，如果你有1000个元素要更新，那么每次都要进行10亿次的比较，这个开销还是很巨大的，试想如果React真有这么大的开销，那他就不是React了。然而React基于以下两个假设，将复杂度降到了<code>O(n) </code>:</p>
<ul>
<li>不同类型的两个元素会产生两个不同的树</li>
<li>开发人员可以使用一个 <code>key</code> 来指示在不同的渲染中哪些元素可以保持稳定</li>
</ul>
<h3 id="Diff算法"><a href="#Diff算法" class="headerlink" title="Diff算法"></a><strong>Diff算法</strong></h3><p>当比较两个树的时候，React首先会比较两个根元素，依据类型的不同会有不同的处理。</p>
<ul>
<li><p>根元素类型不同<br>任何时候，元素的类型不同React都会销毁dom，然后重新构建新的dom。比如<code>a</code>标签换成<code>img</code></p>
</li>
<li><p>元素类型相同<br>当比较两个相同类型的 React DOM 元素时，React 检查它们的属性（attributes），保留相同的底层 DOM 节点，只更新反生改变的属性（attributes）。</p>
</li>
<li><p>组件类型相同<br>react在更新组件的时候，组件实例保持不变，这样可以保持组件的state不变。react会更新组件实例的属性来匹配新的元素。并在实例上调用<code>componentWillReceiveProps()</code>和<code>componentWillUpdate()</code>。<br>接下来，<code>render()</code>方法会被调用，并且diff算法对上一次的结果和新的结果进行递归。</p>
</li>
<li><p>子元素递归<br>在遍历节点的字节点时，一般直接遍历所有子节点就可以。但是在react中这种遍历有时就会有不同的影响</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- dom1 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>first<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>second<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- dom2 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>first<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>second<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>third<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>React 会遍历ul下子节点，first，second没有改变，只在末尾插入third即可，性能良好。但是结构变更一下</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- dom1 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>first<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>second<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- dom2 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>third<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>first<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>second<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>此时，react遍历ul子节点，发现first变成了third，此时会重新渲染这些li，此时性能就会贼差。<br>针对以上问题，react并不会意识到li标签只是新增了一个标签而且，此时并不需要重新渲染这些li。</p>
</li>
</ul>
<p><strong>Keys 横空出世</strong></p>
<blockquote>
<p>key的值必须保证唯一且稳定<br>为了解决这个问题，React 支持一个 <code>key</code> 属性（attributes）。当子节点有了 <code>key</code> ，React 使用这个 <code>key</code> 去比较原来的树的子节点和之后树的子节点。</p>
</blockquote>
<p>同样的结构：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- dom1 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;first&quot;</span>&gt;</span>first<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;second&quot;</span>&gt;</span>second<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- dom2 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;third&quot;</span>&gt;</span>third<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;first&quot;</span>&gt;</span>first<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;second&quot;</span>&gt;</span>second<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>react 遍历子节点，此时只需要比较<code>key</code>的差异即可，发现只是新增third，此时并不会渲染三个li，只是插入</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;third&quot;</span>&gt;</span>third<span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">code</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>即可</p>

        </div>
    </div>
    
</div>
            </div>
            
                <div class="aside">
    
        <div class="web-sidebar-box box-item">
    <div class="sidebar-title">
        <h2>关于我</h2>
    </div>
    <div class="tag-list">
        目前网站处于前期调整阶段
    </div>
</div>
    
        
    <div class="web-sidebar-box box-item">
        <div class="sidebar-title">
            <h2>最新文章</h2>
        </div>
        <div class="latest-list">
            <ul class="item-box">
                
                    <li>
                        <a href="/20220920/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/">
                            1. 两数之和
                        </a>
                    </li>
                
                    <li>
                        <a href="/20211029/20211029/">
                            2. Express + Express-ws 实时通信
                        </a>
                    </li>
                
                    <li>
                        <a href="/20210408/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/">
                            3. 插入排序
                        </a>
                    </li>
                
                    <li>
                        <a href="/20210408/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/">
                            4. 插入排序
                        </a>
                    </li>
                
                    <li>
                        <a href="/20210406/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/">
                            5. 冒泡排序
                        </a>
                    </li>
                
                    <li>
                        <a href="/20210404/20210404/">
                            6. 一个改变的key引发的问题
                        </a>
                    </li>
                
                    <li>
                        <a href="/20210331/20210331/">
                            7. js 数据类型检测
                        </a>
                    </li>
                
                    <li>
                        <a href="/20210328/2021328/">
                            8. 国内github访问速度慢怎么解决
                        </a>
                    </li>
                
            </ul>
        </div>
    </div>

    
</div>
            
            </div>
        <div class="web-footer">
    <h2 class="friend-state">友情声明</h2>
    <div class="coperation">
        <p>本网站部分资料来源于网络，如有任何问题可联系站主解决</p>
    </div>
    <div class="copyright">
        <span>Copyright &copy; 2021</span>
        <span class="dotted">|</span>
        <span>Powered by <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a></span>
        <span class="dotted">|</span>
        <span>Theme by <i>yaming042</i></span>
        
        <!-- <span class="dotted">|</span>
        <span><a href="http://www.beian.miit.gov.cn" target="_blank">豫ICP备17028068号</a></span> -->
    </div>

    <script>
        var APP_ID = '1lDgPz8SjxTtvmbx7wEyRr5K-gzGzoHsz',
            APP_KEY = 'yjGRwyBaWyarq9iIrOOE07zN',
            IS_POST = 'true' === 'true';
    </script>
    
<script src="/js/tg.min.js"></script>

</div>
    </div>


</body>
</html>